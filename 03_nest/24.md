<h1>Projeto 02 - Blog Pessoal - M√≥dulo Auth - Parte 03</h1>

O que veremos por aqui:

1. Criar a Classe AuthService
2. Criar a Classe AuthController
3. Registrar as Classes AuthService e AuthController na Classe AuthModule
4. Atualizar todas as Classes Controladoras
5. Testar o M√©todo Login no Insomnia
6. Atualizar todas as Requisi√ß√µes dos M√≥dulos Usuario, Tema e Postagem

<h2>1. O M√≥dulo Auth</h2>

Nesta etapa vamos finalizar a implementa√ß√£o da seguran√ßa da aplica√ß√£o atrav√©s da Biblioteca Passport. Iremos implementar as 2 ultimas Classes do M√≥dulo Auth: **AuthService** (Classe de Servi√ßo do M√≥dulo Auth) e **AuthController** (Classe Controladora do M√≥dulo Auth).

<br />

<h2>üë£ Passo 01 - Criar a Classe AuthService</h2>

Vamos criar a pasta **services**, dentro do nosso **M√≥dulo Auth** (pasta auth):

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="220px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao criar Classe de Servi√ßo. Um erro muito comum √© digitar o nome da Classe de forma incorreta. O nome da Classe deve estar dentro dos padr√µes do Nest (nome_do_modulo.tipo_da_classe.ts) para evitar erros na sua aplica√ß√£o.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

1. Clique com o bot√£o direito do mouse sobre a **pasta services**, que foi criada dentro da pasta **auth**, como mostra a figura abaixo, e na sequ√™ncia clique na op√ß√£o **New File** (Novo Arquivo).

2. O nome do arquivo ser√° **auth.service.ts**, como mostra a figura abaixo. Ap√≥s digitar o nome do arquivo, pressione a tecla **enter** do seu teclado para concluir. 

<div align="center"><img src="https://i.imgur.com/cEIui2J.png" title="source: imgur.com" /></div>

Veja abaixo a implementa√ß√£o da Classe **AuthService**:

```typescript
import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsuarioService } from '../../usuario/services/usuario.service';
import { Bcrypt } from '../bcrypt/bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private usuarioService: UsuarioService,
    private jwtService: JwtService,
    private bcrypt: Bcrypt
  ) { }

  async validateUser(username: string, password: string): Promise<any> {

    const buscaUsuario = await this.usuarioService.findByUsuario(username)

    const match = await this.bcrypt.compararSenhas(buscaUsuario.senha, password)

    if (buscaUsuario && match) {
      const { senha, ...result } = buscaUsuario;
      return result;
    }
    return null;
  }

  async login(usuarioLogin: any) {

    const payload = { username: usuarioLogin.usuario, sub: "blogpessoal" };

    return {
      usuario: usuarioLogin.usuario,
      token: `Bearer ${this.jwtService.sign(payload)}`,
    };
    
  }

}
```

Vamos analisar a implementa√ß√£o do c√≥digo, com foco nas diferen√ßas em rela√ß√£o aos M√≥dulos anteriores:

<h3> 1.1 M√©todo Constructor()</h3>

O M√©todo **Constructor()** recebe as **Inje√ß√µes de Depend√™ncia** necess√°rias para o desenvolvimento da Classe de Servi√ßo.

<div align="center"><img src="https://i.imgur.com/LTcg323.png" title="source: imgur.com" /></div>

**Linha 10:** Al√©m da Inje√ß√£o de Depend√™ncia da Classe de Servi√ßo usuarioService, o M√©todo receber√° outras duas  Inje√ß√µes de Depend√™ncia:

- **Classe JwtService**, Classe de Servi√ßo respons√°vel por gerar o Token JWT.
- **Classe Bcrypt**, que foi criada como uma Classe de Servi√ßo no M√≥dulo Auth, respons√°vel por checar se o **Atributo senha do Objeto da Classe UsuarioLogin** (senha n√£o criptografada), √© igual ao **Atributo senha do Objeto da Classe Usuario** (criptografada) persistido no Banco de dados.



<h3> 1.2 M√©todo validateUser(username: string, password: string)</h3>

O M√©todo **validateUser(username: string, password: string)** ser√° respons√°vel por **validar os Atributos usuario (e-mail) e a senha** enviados no Objeto UsuarioLogin. Caso os dados dos 2 Atributos sejam validados, o usu√°rio ser√° autenticado.

<div align="center"><img src="https://i.imgur.com/iXySFtS.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo do M√©todo:

**Linha 14:** Criamos o M√©todo Ass√≠ncrono (async), chamado **validateUser(username: string, password: string)**, que promete retornar uma **Promise** com **apenas um** Objeto do tipo **any**.

Observe que o M√©todo **validateUser(username: string, password: string)** possui dois par√¢metros do tipo **string**, chamados **usuario e senha**. Estes par√¢metros ser√£o recebidos na autentica√ß√£o (login) do usu√°rio.

**Linha 16:** Criamos um Objeto da Classe Usuario do tipo **const**, chamado **buscaUsuario**, que receber√° o resultado da execu√ß√£o do M√©todo **findByUsuario(usuario: Usuario)**, da Classe **UsuarioService**, que valida se o usu√°rio existe.

**Linha 18:** Criamos uma **const**, chamada **match**, que receber√° o resultado da execu√ß√£o do M√©todo ****, da Classe **Bcrypt**, que valida se a senha persistida no Banco de dados e a senha enviada no Objeto UsuarioLogin s√£o iguais. Este M√©todo retornar√° true (o termo correto √© Match), caso as senhas sejam iguais.

Veja o exemplo nas imagens abaixo:

<table>
	<tr>
		<td width="50%"><img src="https://i.imgur.com/YCGbZwt.png" title="source: imgur.com" /></td>
		<td width="50%"><img src="https://i.imgur.com/EHEdZea.png" title="source: imgur.com" /></td>
	</tr>
</table>
O site **Bcrypt Generator** simula o funcionamento do algoritmo hash Bcrypt. Observe que inserimos a mesma senha criptografada nas 2 imagens e s√≥ alteramos a senha digitada. Na primeira imagem, que inserimos a senha correta, o site exibe **Match! (true)**, enquanto na segunda imagem, que inserimos a senha incorreta, o site exibe **Not a Match! (false)**. O M√©todo **compararSenhas(senhaBanco: string, senhaDigitada: string)** faz a mesma coisa: Decodifica a senha criptografada e compara com a senha n√£o codificada.

**Linha 20:** Verifica se o **Objeto buscaUsuario foi encontrado** e se a **vari√°vel match √© igual a true**. 

**Linha 21:** Se as 2 condi√ß√µes forem verdadeiras, ser√° criado um Objeto chamado **result** do tipo **const**, retornando o **Objeto Usuario encontrado sem o Atributo senha**, por quest√µes de seguran√ßa e boas pr√°ticas.

**Linha 24:** Se as 2 condi√ß√µes forem falsas, o M√©todo retorna **null** e a aplica√ß√£o retornar√° o HTTP Status **UNAUTHORIZED ü°™ 401** (Acesso n√£o autorizado!).

<h3> 1.3 M√©todo login(usuarioLogin: any)</h3>

O M√©todo **login(usuarioLogin: any)** ser√° respons√°vel por **autenticar (login) um usuario na aplica√ß√£o**. Este M√©todo √© essencial para o funcionamento do **Passport**, porqu√™ sem a autentica√ß√£o n√£o ser√° poss√≠vel acessar aplica√ß√£o e gerar o Token JWT. 

<div align="center"><img src="https://i.imgur.com/fM4Trr7.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo do M√©todo:

**Linha 27:** Criamos o M√©todo Ass√≠ncrono (async), chamado **login(usuarioLogin: any)**.

Observe que o M√©todo **login(usuarioLogin: any)** possui um par√¢metro do tipo **UsuarioLogin**, chamado **usuario**Login. Esta vari√°vel receber√° um Objeto da Classe UsuarioLogin, que ser√° enviado  no Corpo da Requisi√ß√£o (Request Body). O Objeto usuarioLogin ser√° enviado pelo M√©todo da **Classe UsuarioController**, atrav√©s de um **JSON**, semelhante ao exemplo abaixo:

```json
{
    "usuario" : "admin@email.com.br",
    "senha" : "admin123"
}
```

Observe que todos os Atributos da Classe Auxiliar UsuarioLogin ser√£o preenchidos.

Ao receber os dados do Objeto usuarioLogin, o Passport envia o Objeto para a Classe **LocalStrategy**, que est√° esperando por um Objeto contendo os Atributos usuario e senha, e ao receber os 2 Atributos ela se encarregar√° da autentica√ß√£o (login) do usu√°rio. 

Enquanto isso, o M√©todo **login(usuarioLogin: any)** se encarregar√° de gerar o Token JWT, como veremos nas pr√≥ximas linhas.

**Linha 29:** Criamos um Objeto do tipo const, chamado **payload**, que ser√° utilizado na gera√ß√£o do Token JWT. Este Objeto ter√° 2 par√¢metros:

- **username (usu√°rio):** recebe o Atributo usuario (e-mail)
- **sub (subject):** recebe uma string com o nome do projeto (blogpessoal)

Na imagem abaixo vemos a estrutura b√°sica de um Token JWT:

<div align="center"><img src="https://i.imgur.com/fj6noCZ.png" title="source: imgur.com" /></div>

Observe que ele √© composto pelo **Header** (cabe√ßalho), **Payload** (dados do usuario) e a **Signature** (chave de assinatura). O Payload √© a parte customizada do Token, onde definimos as **Claims** (peda√ßos de informa√ß√µes sobre o usuario e o projeto), que desejamos enviar no Token JWT.

**Linhas 31, 32 e 33:** Caso a autentica√ß√£o (login) tenha sido bem sucedido, ser√° retornado um JSON com dois atributos:

- **usuario**
- **Token**, que ser√° gerado a partir do M√©todo **jwtService.sign(payload)**

Observe que o M√©todo **jwtService.sign(payload)** criar√° apenas a parte codificada do Token JWT, por isso foi inserida a palavra **Bearer**, seguida de **um espa√ßo em branco**, **concatenada com a parte codificada do Token JWT**. O **espa√ßo em branco entre a palavra Bearer e a parte codificada do Token JWT √© Obrigat√≥rio!**, caso contr√°rio o Token JWT n√£o ir√° funcionar.

Observe tamb√©m que o Token est√° inserido dentro **2 acentos grave ( ` )**, utilizado na L√≠ngua Portuguesa para indicar um crase, ao inv√©s de aspas simples ( ' ). Veja o trecho destacado na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/sNUXmf9.png" title="source: imgur.com" /></div>

No caso de uma autentica√ß√£o bem sucedida, o retorno esperado do M√©todo **login(usuarioLogin: any)** ser√° um JSON contendo o usuario e o token, como mostra o exemplo abaixo:

```json
{
	"usuario": "admin@email.com.br",
	"token": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluQGVtYWlsLmNvbS5iciIsInN1YiI6ImJsb2dwZXNzb2FsIiwiaWF0IjoxNjU5NjY5MzYwLCJleHAiOjE2NTk3NTU3NjB9.xvlBIb2TSofhpGv6spqRu903vjXCImWKrdqfgwCVf7w"
}
```

<br />

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/kelektiv/node.bcrypt.js#readme" target="_blank"><b>Documenta√ß√£o: Biblioteca Bcrypt JS</b></a> </div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://bcrypt-generator.com/" target="_blank"><b>Ferramenta: Bcrypt Generator</b></a> </div>

<br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_nest/blob/13_Security_JWT/blogpessoal/src/auth/services/auth.service.ts" target="_blank"><b>C√≥digo fonte da Classe AuthService</b></a></div>

<br />

<h2>üë£ Passo 02 - Criar a Classe AuthController</h2>

Vamos criar a Classe Controladora **AuthController** que chamaremos de **auth.controller.ts**. Nesta Classe vamos implementar o endpoint de autentica√ß√£o (login).

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="320px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao criar Classe de Controladora. Um erro muito comum √© digitar o nome da Classe de forma incorreta. O nome da Classe deve estar dentro dos padr√µes do Nest (nome_do_modulo.tipo_da_classe.ts) para evitar erros na sua aplica√ß√£o.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

1. Clique com o bot√£o direito do mouse sobre a **pasta controllers**, que foi criada dentro da pasta **auth**, como mostra a figura abaixo, e clique na op√ß√£o **New File** (Novo Arquivo).

2. O nome do arquivo ser√° **auth.controller.ts**, como mostra a figura abaixo. Ap√≥s digitar o nome do arquivo, pressione a tecla **enter** do seu teclado para concluir. 

<div align="center"><img src="https://i.imgur.com/0BfJra1.png" title="source: imgur.com" /></div>

Veja abaixo a implementa√ß√£o da Classe **AuthController**:

```typescript
import { Body, Controller, HttpCode, HttpStatus, Post, UseGuards } from '@nestjs/common';
import { LocalAuthGuard } from '../guard/local-auth.guard';
import { AuthService } from '../services/auth.service';
import { UsuarioLogin } from './../entities/usuariologin.entity';

@Controller("/auth")
export class AuthController {
    constructor(private authService: AuthService) { }

    @UseGuards(LocalAuthGuard)
    @HttpCode(HttpStatus.OK)
    @Post('/logar')
    async login(@Body() user: UsuarioLogin): Promise<any> {
        return this.authService.login(user);
    }

}
```

Observe que a implementa√ß√£o √© semelhante as demais Classes Controladoras implementadas anteriormente, a √∫nica diferen√ßa est√° no primeiro decorator do M√©todo login: **@UseGuards(LocalAuthGuard)**. Este decorator √© respons√°vel por habilitar a autentica√ß√£o na aplica√ß√£o atrav√©s do M√©todo **login(@Body() user: UsuarioLogin)**. O par√¢metro do decorator, **LocalAuthGuard**, √© a Classe que implementamos dentro da pasta **guards**.

<br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_nest/blob/13_Security_JWT/blogpessoal/src/auth/controllers/auth.controller.ts" target="_blank"><b>C√≥digo fonte da Classe AuthController</b></a></div>

<br />

<h2>üë£ Passo 03 - Registrar as Classes AuthService e AuthController na Classe AuthModule</h2>

Na sequ√™ncia, vamos registrar as nossas Classes **AuthService** e **AuthController**, no M√≥dulo **AuthModule**. 

1. Abra a Classe **AuthModule**, localizada na pasta **auth**, conforme indicada na imagem abaixo:

   <div align="center"><img src="https://i.imgur.com/psjwCZS.png" title="source: imgur.com" /></div>

2. Implemente as altera√ß√µes, indicadas pelas setas na imagem abaixo:

 <div align="left"><img src="https://i.imgur.com/lFk9Cf6.png" title="source: imgur.com" /></div>

Vamos analisar as altera√ß√µes no c√≥digo:

**Linha 21:** No array **providers** vamos adicionar a Classe **AuthService** do **M√≥dulo Auth**. Desta forma a Classe de Servi√ßo poder√° ser injetadas em outras Classes dentro do M√≥dulo Auth.

**Linha 22:** No array **controllers** vamos adicionar a **Classe AuthController** do **M√≥dulo Auth**. Desta forma os endpoints da Classe Controladora estr√£o dispon√≠veis para receber Requisi√ß√µes HTTP.

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao Registrar novas Classes no M√≥dulo. Observe que ap√≥s registrar uma nova Classe, novas importa√ß√µes de Classes ser√£o necess√°rias nas primeiras linhas da Classe M√≥dulo.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="25px"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_nest/blob/13_Security_JWT/blogpessoal/src/auth/auth.module.ts" target="_blank"><b>C√≥digo fonte da Classe AuthModule</b></a></div>

<br />

<h2>üë£ Passo 04 - Altera√ß√µes na Classe UsuarioController</h2>

Vamos configurar os endpoints da Classe **UsuarioController** para utilizarem o Token JWT em alguns endpoints. Veja a tabela abaixo:

| M√©todo                               | Protegido? |
| ------------------------------------ | ---------- |
| **findAll()**                        | Sim        |
| **create(@Body() usuario: Usuario)** | N√£o        |
| **update(@Body() usuario: Usuario)** | Sim        |

Apenas o M√©todo **create(@Body() usuario: Usuario)** n√£o ser√° protegido, porqu√™ sen√£o nenhum usu√°rio conseguir√° se cadastrar e autenticar (login) na aplica√ß√£o.

Vamos adicionar o decorator **@UseGuards(JwtAuthGuard)** nos M√©todos findAll() e update(@Body() usuario: Usuario) da Classe UsuarioController. Este decorator √© respons√°vel por habilitar a valida√ß√£o do Token JWT em todas as requisi√ß√µes que o M√©todo receber. O par√¢metro do decorator, **JwtAuthGuard**, √© a Classe que implementamos dentro da pasta **guards**.

Ap√≥s adicionar os decorators, nossa Classe Controladora UsuarioController ter√° a seguinte implementa√ß√£o:

```typescript
import { Body, Controller, Get, HttpCode, HttpStatus, Post, Put, UseGuards } from "@nestjs/common";
import { JwtAuthGuard } from "../../auth/guard/jwt-auth.guard";
import { Usuario } from "../entities/usuario.entity";
import { UsuarioService } from "../services/usuario.service";

@Controller("/usuarios")
export class UsuarioController {
    constructor(private readonly usuarioService: UsuarioService) { }

    @UseGuards(JwtAuthGuard)
    @Get('/all')
    @HttpCode(HttpStatus.OK)
    findAll(): Promise<Usuario[]> {
        return this.usuarioService.findAll();
    }

    @HttpCode(HttpStatus.CREATED)
    @Post('/cadastrar')
    async create(@Body() usuario: Usuario): Promise<Usuario> {
        return await this.usuarioService.create(usuario);
    }

    @UseGuards(JwtAuthGuard)
    @Put('/atualizar')
    @HttpCode(HttpStatus.OK)
    async update(@Body() usuario: Usuario): Promise<Usuario> {
        return this.usuarioService.update(usuario);
    }

}
```

Observe que o decorator **@UseGuards(JwtAuthGuard)** foi adicionados na assinatura de cada M√©todo protegido.

<br />

<h2>üë£ Passo 05 - Altera√ß√µes na Classe TemaController</h2>

Vamos configurar a Classe **TemaController** para utilizar o Token JWT em todos os endpoints. Como todos os M√©todos ser√£o protegidos, vamos adicionar o decorator **@UseGuards(JwtAuthGuard)** na assinatura da Classe, ao inv√©s de adicionarmos o decorator em cada M√©todo como fizemos na Classe UsuarioController. Abaixo voc√™ confere o c√≥digo com o decorator implementado:

```typescript
import { Body, Controller, Delete, Get, HttpCode, HttpException, HttpStatus, Param, ParseIntPipe, Post, Put, UseGuards } from "@nestjs/common";
import { JwtAuthGuard } from "../../auth/guard/jwt-auth.guard";
import { Tema } from "../entities/tema.entity";
import { TemaService } from "../services/tema.service";

@UseGuards(JwtAuthGuard)
@Controller("/tema")
export class TemaController {
  constructor(private readonly temaService: TemaService) { }

  @Get()
  @HttpCode(HttpStatus.OK)
  findAll(): Promise<Tema[]> {
    return this.temaService.findAll();
  }

  @Get('/:id')
  @HttpCode(HttpStatus.OK)
  findById(@Param('id', ParseIntPipe) id: number): Promise<Tema> {
    return this.temaService.findById(id);
  }

  @Get('/descricao/:descricao')
  @HttpCode(HttpStatus.OK)
  findBydescricao(@Param('descricao') descricao: string): Promise<Tema[]> {
    return this.temaService.findByDescricao(descricao);
  }

  @Post()
  @HttpCode(HttpStatus.CREATED)
  create(@Body() Tema: Tema): Promise<Tema> {
    return this.temaService.create(Tema);
  }

  @Put()
  @HttpCode(HttpStatus.OK)
  update(@Body() Tema: Tema): Promise<Tema> {
    return this.temaService.update(Tema);
  }

  @Delete('/:id')
  @HttpCode(HttpStatus.NO_CONTENT)
  delete(@Param('id', ParseIntPipe) id: number){
    return this.temaService.delete(id);
  }

}
```

<br />

<h2>üë£ Passo 06 - Altera√ß√µes na Classe PostagemController</h2>

Vamos configurar a Classe **PostagemController** para utilizar o Token JWT em todos os endpoints. Como todos os M√©todos ser√£o protegidos, vamos adicionar o decorator **@UseGuards(JwtAuthGuard)** na assinatura da Classe, ao inv√©s de adicionarmos o decorator em cada M√©todo como fizemos na Classe UsuarioController. Abaixo voc√™ confere o c√≥digo com o decorator implementado:

```typescript
import { Controller, Get, Post, Put, Delete, HttpCode, HttpStatus, Param, Body, HttpException, UseGuards, ParseIntPipe } from "@nestjs/common";
import { JwtAuthGuard } from "../../auth/guard/jwt-auth.guard";
import { Postagem } from "../entities/postagem.entity";
import { PostagemService } from "../services/postagem.service";

@UseGuards(JwtAuthGuard)
@Controller("/postagens")
export class PostagemController {
  constructor(private readonly postagemService: PostagemService) { }

  @Get()
  @HttpCode(HttpStatus.OK)
  findAll(): Promise<Postagem[]> {
    return this.postagemService.findAll();
  }

  @Get('/:id')
  @HttpCode(HttpStatus.OK)
  findById(@Param('id', ParseIntPipe) id: number): Promise<Postagem> {
    return this.postagemService.findById(id);
  }

  @Get('/titulo/:titulo')
  @HttpCode(HttpStatus.OK)
  findByTitulo(@Param('titulo') titulo: string): Promise<Postagem[]> {
    return this.postagemService.findByTitulo(titulo);
  }

  @Post()
  @HttpCode(HttpStatus.CREATED)
  create(@Body() postagem: Postagem): Promise<Postagem> {
    return this.postagemService.create(postagem);
  }

  @Put()
  @HttpCode(HttpStatus.OK)
  update(@Body() postagem: Postagem): Promise<Postagem> {
    return this.postagemService.update(postagem);
  }

  @Delete('/:id')
  @HttpCode(HttpStatus.NO_CONTENT)
  delete(@Param('id', ParseIntPipe) id: number){
    return this.postagemService.delete(id);
  }

}
```

<br />

<h2>üë£ Passo 07 - Executar o projeto</h2>

1. Verifique se voc√™ est√° dentro da pasta do projeto, como mostra a figura abaixo:


<div align="center"><img src="https://i.imgur.com/67GK3fX.png" title="source: imgur.com" /></div>

2. Digite o comando ***npm run start:dev***, para compilar e executar o nosso projeto **blogpessoal**, caso n√£o esteja em execu√ß√£o. 

```bash
npm run start:dev
```

3. Se tudo deu certo, o resultado ser√° semelhante ao da figura abaixo:

<div align="center"><img src="https://i.imgur.com/kW5dccM.png" title="source: imgur.com" /></div>

4.Observe que o endpoint **logar**, do **M√≥dulo Auth** foi disponibilizado no endere√ßo **/auth/logar** 

<br />

<h2>üë£ Passo 08 - Testar o M√≥dulo Auth no Insomnia</h2>

Vamos criar no Insomnia, **dentro da pasta usuario**, a requisi√ß√£o Autenticar Usu√°rio:

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left"> **DICA:** *Caso voc√™ tenha alguma d√∫vida sobre como criar as Requisi√ß√µes, consulte a Documenta√ß√£o dos M√≥dulos Postagem, Tema e Usuario.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<h3>6.1. Criando a  Requisi√ß√£o - Autenticar Usu√°rio (Login)</h3>

1. Clique com o bot√£o direito do mouse sobre a **Pasta Usuario** para abrir o menu e clique na op√ß√£o **New Request**.

2. Ser√° criada uma nova Requisi√ß√£o (New Request) dentro da pasta **Usuario**.

3. D√™ um duplo clique sobre a nova requisi√ß√£o (**New Request**), informe o nome da requisi√ß√£o (indicado na imagem abaixo na cor amarela) e pressione a tecla **enter** do seu teclado.

<div align="center"><img src="https://i.imgur.com/sVVW1sF.png" title="source: imgur.com" /></div>

4. Selecione o M√©todo HTTP que ser√° utilizado (**POST**) na requisi√ß√£o, indicado na imagem abaixo na cor verde. 

<div align="center"><img src="https://i.imgur.com/TLBY2tJ.png" title="source: imgur.com" /></div>

5. No item **Body**, vamos alterar para **JSON**, como mostra a imagem abaixo. Desta forma poderemos enviar os dados do Objeto **UsuarioLogin** no Corpo da Requisi√ß√£o, no formato JSON.

<div align="center"><img src="https://i.imgur.com/PxOpzFd.png" title="source: imgur.com" /></div>

6. Observe que o item **Body** ser√° renomeado para **JSON**, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/8hDNIbh.png" title="source: imgur.com" /></div>

7. Configure a requisi√ß√£o conforme a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/KjboUbP.png" title="source: imgur.com" /></div>

8. Observe que no JSON estamos informando apenas o usu√°rio e a senha, porqu√™ s√£o os dois √∫nicos Atributos da Classe **UsuarioLogin**. Se o login for efetuado com sucesso, ser√° retornado um JSON no Corpo da Resposta, como vemos na figura abaixo:

<div align="center"><img src="https://i.imgur.com/n95caRD.png" title="source: imgur.com" /></div>

9. Observe que o JSON retornado no Corpo da Resposta possui 2 Atributos: **usuario** (e-mail) e o **token** no padr√£o JWT.

| <img src="https://i.imgur.com/L338M2G.png" title="source: imgur.com" width="80px"/> | **DESAFIO:** *Experimente executar as outras Requisi√ß√µes, que foram criadas anteriormente no Insomnia. Elas funcionaram?* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<h3>6.2. Adicionar o Token JWT na Requisi√ß√£o Consultar todos os Usuarios</h3>

Se voc√™ fez o teste no Desafio acima, deve ter notado que todas Requisi√ß√µes, **exceto Cadastrar Usu√°rio** retornaram o HTTP Status **UNAUTHORIZED ü°™ 401** (Acesso n√£o autorizado!), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/67HdR7U.png" title="source: imgur.com" /></div>

A explica√ß√£o √© simples: **Todos os M√©todos protegidos precisam receber um Token JWT v√°lido para autorizar a Requisi√ß√£o**. Vamos configurar a Requisi√ß√£o Consultar todos os Usu√°rios para enviar o Token no cabe√ßalho da Requisi√ß√£o. 

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes. Os passos que ser√£o apresentados a seguir voc√™ dever√° fazer em todas as Requisi√ß√µes, de todos os M√≥dulos, exceto Autenticar Usu√°rio e Cadastrar Usu√°rio.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="120px"/> | <div align="left"> **MUITA ATEN√á√ÉO!** *Lembre-se que o Token JWT permanece v√°lido por apenas 24 horas. Passadas as 24 horas, voc√™ precisar√° logar, obter um novo Token JWT e trocar  o Token em todas as Requisi√ß√µes do Insomnia, exceto Autenticar Usu√°rio e Cadastrar Usu√°rio.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |


1. Vamos abrir a Requisi√ß√£o Consultar todos os Usu√°rios.


<div align="center"><img src="https://i.imgur.com/Veedyux.png" title="source: imgur.com" /></div>

4. Clique na Guia **Header**.

<div align="center"><img src="https://i.imgur.com/VYYcCfH.png" title="source: imgur.com" /></div>

5.  No Campo **New header**, adicione a propriedade **Authorization**.

<div align="center"><img src="https://i.imgur.com/lvA616E.png" title="source: imgur.com" /></div>

6.  Volte na Requisi√ß√£o **Autenticar Usu√°rio**, **selecione o Token inteiro, exceto as aspas**, como mostra a imagem abaixo e copie.

<div align="center"><img src="https://i.imgur.com/Gh3IkqH.png" title="source: imgur.com" /></div>

7. No campo **Value** da propriedade **Authorization**, cole o **Token** que voc√™ copiou na Requisi√ß√£o **Autenticar Usu√°rio**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/AwlzvSI.png" title="source: imgur.com" /></div>

8. Teste a Requisi√ß√£o novamente. Agora ela deve estar funcionando!

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="120px"/> | <div align="left"> **MUITA ATEN√á√ÉO!** **N√£o esque√ßa de adicionar o Token JWT em todas as Requisi√ß√µes, de todos os M√≥dulos, exceto Autenticar Usu√°rio e Cadastrar Usu√°rio**.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="35px"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_nest/tree/13_Security_JWT" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>

