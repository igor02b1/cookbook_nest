<h1>Primeiros passos com NestJS</h1>

O NestJS, ou simplesmente Nest, é um framework back-end, que auxilia no processo de desenvolvimento de aplicações JavaScript/Typescript eficientes, escaláveis e confiáveis em cima do Node.js. O Nest utiliza como padrão a linguagem  TypeScript e possui uma sintaxe muito parecida com a do **Framework Angular**. Um detalhe importante sobre o Nest é que ele utiliza em segundo plano o **Framework Node Express**. 

> **[Angular](https://angular.io/):** Plataforma de aplicações web de código-fonte aberto e front-end, baseado em TypeScript, liderado pela Equipe Angular do Google e por uma comunidade de indivíduos e corporações. Angular é uma reescrita completa do AngularJS, feito pela mesma equipe que o construiu.
>
> **[Express.js](https://expressjs.com/pt-br/):** Framework para Node.js, muito popular, que fornece os recursos mínimos para construção de servidores web. Foi lançado como software  livre e de código aberto sob a Licença MIT. É um dos mais populares  frameworks para servidores em Node.js

<br />

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="30px"/> <a href="https://nestjs.com/" target="_blank"><b>Site Oficial: NestJS</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/pt/docs/" target="_blank"><b>Documentação: TypeScript</b></a></div>

<br />

O grande diferencial do Nest em relação ao Node.js (Express), está no nível de abstração bem acima das estruturas comuns do Node, além de expor as suas API's diretamente à pessoa desenvolvedora, garantindo a liberdade de usar uma infinidade de Módulos de terceiros que estão disponíveis para a plataforma, tornando possível termos uma aplicação rodando em produção rapidamente e com o esforço mínimo de configuração e implantação. 

> Na **programação**, a **abstração** sugere a distinção que deve ser feita entre “o que” o programa faz e “como” ele é implementado. Por exemplo, quando um Método é chamado, pode-se concentrar somente no que ele faz; apenas quando se está escrevendo o Método é que deve-se concentrar em como fazer.

<br />

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot" target="_blank"><b>Documentação do NestJS</b></a>

 <br />

Para facilitar ainda mais, o Nest disponibiliza o **Nest CLI**, uma ferramenta de linha de comando (executada a partir do prompt de comando, Power Shell, Bash e etc), que com apenas um comando você cria um projeto básico do Nest inteiro. 

O NestCLI cria uma nova pasta com o nome do projeto, nesta pasta o repositório local do Git já está inicializado (precisa apenas conectar com o seu repositório remoto), o módulo app (Módulo principal da aplicação) funcional, uma estrutura base para o seu projeto, além dos pacotes necessários para iniciar a sua aplicação. A criação de um novo projeto com a NestCLI é recomendada especialmente para usuários iniciantes. 

<h2>1. NPM</h2>

O **NPM** (**Node Package Manager**) é o Gerenciador de Pacotes do NodeJS, semelhante ao Maven e o Graddle do Java. O Gerenciador de Pacotes é automaticamente instalado na sua máquina durante a instalação do NodeJS e é muito útil no Desenvolvimento de aplicações JavaScript/TypeScript com o Node. Por anos, o Node tem sido amplamente usado por desenvolvedores JavaScript para compartilhar ferramentas, instalar vários módulos e gerenciar suas dependências. Sabendo disso, é realmente importante para pessoas que trabalham com Node.js entenderem minimamente o que é o npm. 

<div align="left"><img src="https://i.imgur.com/N8NL9fx.png" title="source: imgur.com" width="40px"/><a href="https://www.npmjs.com/" target="_blank"><b> Site Oficial do NPM</b></a></div>

Todas as ferramentas e bibliotecas utilizadas nos projetos NestJS estão disponíveis no servidor do NPM, que funciona como um repositório de pacotes Node. Este repositório facilita e centraliza o download de todos os pacotes, independente de serem as oficiais do Node ou Desenvolvidos por outras empresas ou pessoas desenvolvedoras, dispensando a necessidade de procurar os pacotes no Google, por exemplo. Na imagem abaixo, vemos a página inicial do NPM:

<br />

<div align="center"><img src="https://i.imgur.com/8xAtyxQ.png?1" title="source: imgur.com" /></div>

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="180px"/> | <div align="left"> **ATENÇÃO:** *O NPM é uma Ferramenta de Linha de comando (instalada pelo Node no seu computador), que ajuda a interagir com o Repositório de Pacotes do NodeJS, que também se chama NPM.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

Outro ponto importante a ser destacado no NPM é que um projeto Nest utiliza muitos pacotes, que gera alguns problemas no dia a dia, tais como: manter todos os pacotes atualizados, fazer o build e executar a sua aplicação, realizar testes na aplicação, entre outros. O **NPM** também auxilia nestes processos do dia a dia, através dos seus Scripts prontos que automatizam todas estas tarefas e simplificam o dia a dia da pessoa Desenvolvedora.

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="120px"/> | <div align="left">**DICA:** *Além do NPM, existe um outro Gerenciador de Pacotes para projetos Node chamado **Yarn**. Para saber mais, acesse: https://classic.yarnpkg.com/en/* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<h2>2. Como funciona um projeto NestJS?</h2>

1. A Classe Principal (main.ts), inicia um servidor WEB (NodeJS), que vai gerenciar todos os endpoints disponíveis na API.

2. Cada URL deve ser mapeada para um determinado Módulo, que indicará um determinado Método de uma Classe Controladora para processar a requisição enviada para o servidor.

3. A Classe Controladora acionará uma Classe de Serviço, que possui um Método com todas as regras de negócio pertinentes ao endpoint implementadas. 

4. A execução desse Método na Classe de Serviço retornará uma Resposta, que será processada pela Classe Controladora. 

5. A Classe Controladora processa o retorno do Método e devolve uma Resposta HTTP, contendo um Status Code e o resultado do processamento da aplicação (um Objeto persistido, uma lista de Objetos e etc).

<div align="left"><img src="https://i.imgur.com/kpBWmL1.png" title="source: imgur.com" width="35px"/> <a href="https://nodejs.org/en/" target="_blank"><b>Site Oficial: NodeJS</b></a></div>

<h3>2.1 Como planejar um projeto NestJS?</h3>

Quais Módulos nossa aplicação precisará para solucionar o problema que a aplicação se propõe?

Quais endpoints vamos oferecer? 

> Um endpoint é um caminho (/postagens), que associado a um método do protocolo HTTP (GET, POST, PUT, DELETE), gera uma ação em nossa aplicação.


Em geral, temos pelo menos um endpoint para cada método HTTP (podemos ter mais de um desde que os caminhos sejam diferentes), em cada objeto do nosso modelo de negócios.

Módulo: **Postagem**

- Endpoint para recuperar todos os dados de uma postagem (GET) 
- Endpoint para inserir uma nova postagem (POST)
- Endpoint para atualizar dados de uma postagem (PUT)
- Endpoint para remover uma postagem (DELETE)

Como estes endpoints estarão estruturados no nosso sistema? 

Vamos discutir isto mais adiante...

<h1>Projeto 01 - Hello World!</h1>

<h2>👣 Passo 01 - Instalando o Nest</h2>

Para desenvolver os nossos projetos Nest utilizaremos o **Visual Studio Code (VSCode)**. Para executarmos os Projetos Nest vamos precisar também do **Node** instalado no computador.

<div align="left"><img src="https://i.imgur.com/sOdL7HU.png" title="source: imgur.com" width="30px"/> <a href="https://code.visualstudio.com/download" target="_blank"><b>Site Oficial: VSCode</b></a>

 <div align="left"><img src="https://i.imgur.com/kpBWmL1.png" title="source: imgur.com" width="30px"/> <a href="https://nodejs.org/en/" target="_blank"><b>Site Oficial: NodeJS</b></a>

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="180px"/> | <div align="left"> **DICA:** *Caso você tenha alguma dúvida quanto a instalação do VSCode, consulte o <a href="../00_ambiente/06_install_vscode.md" >Guia de Instalação do VSCode </a>. Caso você tenha alguma dúvida quanto a instalação do Node, consulte o <a href="../00_ambiente/07_install_node.md" >Guia de Instalação do Node </a>.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

1. Crie uma pasta na **Área de Trabalho** do Windows chamada **nestjs**
1. Abra o VSCode

<div align="center"><img src="https://i.imgur.com/AtTA7K4.png" title="source: imgur.com" /></div>

3. No VSCode, abra a pasta **nestjs** através do menu **File 🡪 Open Folder...**

<div align="center"><img src="https://i.imgur.com/TgvVW26.png" title="source: imgur.com" /></div>

4. Abra o Terminal do VSCode através do menu **Terminal 🡪 New Terminal**

<div align="center"><img src="https://i.imgur.com/4rdobXK.png?1" title="source: imgur.com" /></div>

5. Será aberta a tela do **Power Shell** na parte inferior da janela do VSCode.

   <div><img src="https://i.imgur.com/UAgppG0.png" title="source: imgur.com" /></div>

6. Antes de começarmos a instalação do Nest, vamos checar se o Node está instalado corretamente através do comando abaixo:

```bash
node -v
```
<div><img src="https://i.imgur.com/boUzHVu.png" title="source: imgur.com" /></div>

7. Verifique também se o **NPM** está instalado através do comando:

```bash
npm -v
```

<div><img src="https://i.imgur.com/UvLH8lY.png" title="source: imgur.com" /></div>

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="180px"/> | <p align="justify"> **ATENÇÃO:** No momento em que este material foi escrito, a versão LTS mais atual do Node era a versão 16.15.1 LTS. Ao utilizar este material no futuro, pode ser que a versão mais atual seja outra* </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ATENÇÃO:** *Ao executar os comandos do NPM no PowerShell, caso apareça a mensagem de erro: Cannot be loaded because running scripts is disabled on this system, <a href="config_vscode_nest.md">clique aqui</a> e veja como corrigir. * </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

8. Para instalar o **Nest**, digite o comando abaixo

```bash
npm i -g @nestjs/cli
```
9. Ao concluir a instalação será exibida a mensagem abaixo:

<div align="center"><img src="https://i.imgur.com/Eg3un4k.png" title="source: imgur.com" /></div>

8. Verifique se o **Nest** está instalado através do comando:

```bash
nest -v
```

<div align="center"><img src="https://i.imgur.com/bf1Rtp2.png" title="source: imgur.com" /></div>

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="180px"/> | <p align="justify"> **ATENÇÃO:** No momento em que este material foi escrito, a versão mais atual do NestJS era a versão 8.2.8.  Ao utilizar este material no futuro, pode ser que a versão mais atual seja outra* </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<h2>👣 Passo 02 - Criando o Projeto com o NestCLI</h2>

1. Ainda no Terminal, digite o comando ***nest new <nome do projeto>***, onde <nome do projeto> é o nome do seu projeto. No nosso exemplo, **hello-world**. 

```bash
nest new hello-world
```

2. O **NestCLI** criará a estrutura de pastas, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/F9KOn9x.png" title="source: imgur.com" /></div>

3. Na sequência, perguntará **Qual o Gerenciador de Pacotes que você deseja utilizar?** Selecione o **npm** e pressione tecla **enter** do seu teclado (Terminal não utiliza mouse).

<div align="center"><img src="https://i.imgur.com/uvo9mbB.png" title="source: imgur.com" /></div>

4. Ao finalizar a criação do projeto, será exibida a mensagem abaixo:

<div align="center"><img src="https://i.imgur.com/kBaMsMx.png" title="source: imgur.com" /></div>

5. O Projeto hello-world está criado!

<h2>👣 Passo 03 - Conhecendo o Projeto Nest</h2>

A estrutura do pastas do nosso projeto Nest (hello-world) ﬁcará semelhante a imagem abaixo:

 <div align="center"><img src="https://i.imgur.com/Y1XQRTK.png" title="source: imgur.com" /></div>

<h3>3.1 Entendendo a Estrutura do nosso projeto</h3>

| Item                    | Descrição                                                    |
| ----------------------- | ------------------------------------------------------------ |
| **node_modules**        | Nesta pasta o NPM salva todos os pacotes necessários para a aplicação funcionar. |
| **src**                 | Esta é a pasta mais importante da aplicação, onde será desenvolvido todo o código da API Nest. <br />Dentro desta pasta existem 5 arquivos que formam o Módulo principal da aplicação (**app**), além da Classe **main.ts**, que é responsável por inicializar a aplicação. <br /> **Não apague a Classe main.ts sobre hipótese alguma**. |
| **test**                | Nesta pasta serão desenvolvidas as Classes de Teste da aplicação. |
| **.eslintrc.js**        | Configurações do pacote Eslint. Este pacote é responsável pelo processo de aplicar regras (boas práticas) no  código TypeScript e destacar padrões incorretos ou códigos problemáticos que não aderem a determinadas diretrizes de estilo. Exemplo: código com recuo (identação) de 4 espaços em branco ao invés de 2. |
| **nest-cli.json**       | Arquivo de configuração do NestCli                           |
| **package.json**        | Este arquivo armazena todas as configurações necessárias para o projeto NestJS funcionar, ou seja, a lista de pacotes e as configurações do projeto. |
| **package-lock.json**   | Este arquivo é gerado automaticamente para qualquer operação em que o npm modifique a pasta  `node_modules` ou o arquivo `package.json`. Ele descreve a árvore (estrutura de pacotes e suas configurações), exata que foi gerada pelo NPM, de modo que as instalações subsequentes possam gerar árvores idênticas, independentemente das atualizações de dependências intermediárias. |
| **tsconfig.json**       | O arquivo tsconfig.json em uma pasta indica que ela é a pasta raiz de um projeto TypeScript. O arquivo tsconfig.json especifica os arquivos da pasta raiz e as opções que o compilador precisará  para compilar o projeto que utiliza a linguagem TypeScript. |
| **tsconfig.build.json** | O arquivo tsconfig.build.json tem a mesma função do arquivo tsconfig.json, entretanto ele é voltado para o Build do projeto, ou seja, a versão finalizada do projeto, pronta para produção. |

<div align="left"><img src="https://i.imgur.com/N8NL9fx.png" title="source: imgur.com" width="30px"/> <a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json" target="_blank"><b>Documentação: package.json</b></a></div>

<div align="left"><img src="https://i.imgur.com/N8NL9fx.png" title="source: imgur.com" width="30px"/> <a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-lock-json" target="_blank"><b>Documentação: package-lock.json</b></a></div>

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="30px"/> <a href="https://docs.nestjs.com/cli/overview" target="_blank"><b>Documentação: NestCLI</b></a></div>

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/pt/docs/handbook/tsconfig-json.html" target="_blank"><b>Documentação: tsconfig</b></a></div>

<h2>👣 Passo 04 - Conhecendo o Módulo app</h2>

Dentro da pasta src, temos alguns arquivos TypeScript que são responsáveis por inicializar o nosso projeto. Estas classes são geradas automaticamente pelo NestJS durante a criação do projeto e juntas formam o Módulo app da aplicação. Vamos conhecer estas Classes:

<div align="center"><img src="https://i.imgur.com/6dQ1AP4.png" title="source: imgur.com" /></div>

| Classe                 | Descrição                                                    |
| ---------------------- | ------------------------------------------------------------ |
| main.ts                | Classe principal da aplicação. Usando o método *NestFactory.create()* , uma nova instância do aplicativo Nest é criada. |
| app.module.ts          | Contém a implementação do módulo raiz do aplicativo.         |
| app.controller.ts      | Contém a implementação de um controlador NestJS básico com apenas uma rota. |
| app.service.ts         | Contém a implementação de um serviço básico.                 |
| app.controller.spec.ts | Contém a implementação de um teste para o controlador.       |

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Atenção aos Detalhes! Observe o padrão de nomes das Classes. Ao criar novas Classes em um projeto Nest este padrão deve ser respeitado <recurso>.<tipo_da_classe>.ts.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/first-steps#platform" target="_blank"><b>Documentação: <i>Estrutura do Projeto NestJS</i></b></a>

Vamos olhar o código das Classes **main, app.module, app.service e app.controller**.

<h3>4.1. Classe Main</h3>

<div align="center"><img src="https://i.imgur.com/Cq41Vi4.png" title="source: imgur.com" /></div>

**Linha 1:** *NestFactory* é importada da biblioteca *@nestjs/core* . 

**Linha 2:** O Módulo *AppModule* foi importado do arquivo *app.module.ts* (Módulo principal da aplicação) do nosso projeto.

**Linha 4:** A função *bootstrap* é implementada e marcada como *assíncrona*. 

**Linha 5:** O método *NestFactory.create()* é chamado e o Módulo principal da aplicação (*AppModule*) é passado para essa chamada de função como um argumento. Esta chamada cria uma nova instância do aplicativo NestJS com o respectivo módulo anexado. 

**Linha 6:** Para iniciar o servidor, o próximo passo é chamar o método *listen* e passar a porta na qual o servidor web deve estar rodando, por exemplo, **porta 3000**. Como o método listen está retornando uma Promisse (promessa), que o servidor será iniciado com sucesso, usamos a palavra-chave await para pausar a execução da função e esperar que a promisse seja resolvida.

**Linha 8:** A Classe é finalizada com a chamada da função **bootstrap()**, para que o código seja executado.

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/first-steps#platform" target="_blank"><b>Documentação: <i>Classe Main</i></b></a>

<br /><br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="30px"/> <a href="Mudar" target="_blank"><b>Código fonte da Classe Main</b></a>
<br /><br />

<h3>4.2. Classe AppService</h3>

<div align="center"><img src="https://i.imgur.com/RilsjvN.png" title="source: imgur.com" /></div>

**Linha 1:** O Decorator *@Injectable* foi importado do pacote *@nestjs/common* .

> **Decorator:** É um tipo especial de declaração que pode ser anexada na assinatura de uma Classe, um Método, um Atributo ou um Parâmetro. Decorators usam a forma @expression, onde expressão deve resultar em uma função que será chamada em tempo de execução com informações sobre a declaração decorada. Exemplo: @Injectable indica que a Classe é uma Classe de Serviço.

**Linha 3:** Para tornar *AppService* uma classe de Serviço (Provider), o Decorator *@Injectable* foi adicionado antes da assinatura da Classe. Observe que a assinatura da Classe foi iniciada com o comando *export*. Este comando torna a Classe de Serviço visível ("injetável") em qualquer Controladora da aplicação.

> **Provider:** Provedor é uma Classe que pode ser **injetada** como uma dependência; isso significa que os Objetos podem criar vários relacionamentos uns com os outros, e esta função de relacionar as instâncias dos Objetos pode ser amplamente delegada ao Nest.

**Linha 5:** Foi criado o Método *getHello()* . Este método está apenas retornando a string estática “Hello World!”. Em um cenário do mundo real, um método de serviço poderia ser usado para recuperar dados, por exemplo, de um Banco de dados, um serviço da Web ou alguma outra fonte de dados.

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/providers" target="_blank"><b>Documentação: <i>Providers - Service</i></b></a>

<div align="left"><img src="https://i.imgur.com/izFuHID.png" title="source: imgur.com" width="30px"/> <a href="https://www.typescriptlang.org/docs/handbook/decorators.html" target="_blank"><b>Documentação: Decorators</b></a></div>

<br /><br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="30px"/> <a href="Mudar" target="_blank"><b>Código fonte da Classe AppService</b></a>

<br /><br />

<h3>4.3. Classe AppController</h3>

<div align="center"><img src="https://i.imgur.com/cAUEx9R.png" title="source: imgur.com" /></div>

**Linha 1:** Os Decorators *@Controller* e *@Get* foram importados do pacote *@nestjs/common* .

**Linha 2:** A Classe *AppService* foi importada do arquivo *app.service.ts* (Service principal da aplicação) do nosso projeto.

**Linha 4:** Para tornar *AppController* uma Classe Controladora (Controller), adicionamos o Decorator *@Controller*  na assinatura da Classe. 

**Linha 6:** Uma Classe Controladora depende de uma Classe de Serviço, em nosso exemplo, o *AppController* usa o serviço *AppService*, e por isso a instrução de importação da *AppService* foi adicionada na linha 2. Ao usar o conceito de **Injeção de Dependência**, o *AppService* é inserido no AppController (adicionando um parâmetro Construtor do tipo AppService).

**Linha 8:** Para declarar que este método trata uma Requisição HTTP GET, o Decorator *@Get* foi adicionado no Método *getHello*. Como o Decorator *@Get* não possui nenhum parâmetro, indica que o método getHello() responderá a todas as requisições do tipo **HTTP GET**, enviadas no endereço: http://localhost:3000/ 

Relembrando o modelo de uma Requisição HTTP:

- **Servidor:** Endereço do servidor local, ou seja, o seu computador (http://localhost:3000). A porta 3000 foi definida na Classe Main.
- **URL:** Endereço da requisição (/)
- **Verbo:** Define qual método HTTP será acionado na Classe controladora (GET).
- **Corpo da requisição (Request Body):** Objeto que contém os dados que serão criados ou atualizados (GET não possui corpo da requisição).

Linha 10:  O Método *getHello* da Classe Controladora *AppController* está usando o Método *getHello()* da Classe de Serviço *AppService* para recuperar os dados e, ao mesmo tempo, retornar esses dados como Resposta (a string Hello World!).

Após receber e processar a requisição, a Classe Controladora Responderá com:

- Um **Código de Status HTTP** pertinente a operação que está sendo realizada (neste exemplo 200 🡪 OK )
- O resultado do processamento (Dados de uma consulta, por exemplo) inserido diretamente no Corpo da resposta (**Response Body**)

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="25px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods" target="_blank"><b>Documentação: HTTP Methods Request</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="25px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status" target="_blank"><b>Documentação: HTTP Status Code</b></a></div>

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.spring.io/spring-framework/docs/5.0.13.RELEASE/spring-framework-reference/web.html#mvc-ann-controller" target="_blank"><b>Documentação: <i>Controller</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/controllers#routing" target="_blank"><b>Documentação: <i>Routing - Http Methods</i></b></a></div>

<br /><br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="30px"/> <a href="Mudar" target="_blank"><b>Código fonte da Classe AppController</b></a>


<br /><br />

<h3>4.4. Classe AppModule</h3>

<div align="center"><img src="https://i.imgur.com/oTXyujQ.png" title="source: imgur.com" /></div>

**Linha 1:** O Decorator *@Module* foi importado do pacote *@nestjs/common* .

**Linha 2:** A Classe *AppController* foi importada do arquivo *app.controller.ts* (Controller principal da aplicação) do nosso projeto.

**Linha 3:** A Classe *AppService* foi importada do arquivo *app.service.ts* (Service principal da aplicação) do nosso projeto.

**Linha 5:** Para declarar a classe *AppModule* como um Módulo, adicionamos o Decorator *@Module*, além de um objeto com três propriedades:

- imports (Importações)
- controllers (Controladores)
- providers (Provedores)

**Linha 6:** A propriedade *imports* é uma lista opcional de módulos importados, que exportam os provedores (Services), que são necessários neste módulo.

**Linha 7:** A propriedade *controllers* registra todas as Classes Controladoras que devem fazer parte do Módulo (*AppModule*) no array que é atribuído à propriedade *controllers* (no estado inicial da aplicação existe apenas uma Classe Controladora registrada: *AppController* ).

**Linha 8:** A propriedade *providers* registra todas as Classes de Serviço que devem estar disponíveis no Módulo (*AppModule*) no array que é atribuído à propriedade *providers* (no estado inicial da aplicação existe apenas uma Classe de Serviço registrada: *AppService* ).

**Linha 10:** *export class AppModule {}* caso seja necessário exportar alguns provedores, que são fornecidos por este módulo, e necessitem estar disponíveis em outros módulos, que importam este módulo, estes provedores precisam ser registrados nesta linha. Em nosso exemplo, como temos apenas apenas um Módulo e uma Classe de Serviço, nenhum provedor foi passado.

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Atenção aos Detalhes! Todos os Módulos que forem construídos dentro do Nest sempre terão essa estrutura como base: Classe de Serviço, Classe Controladora e ambas registradas no Módulo.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/modules" target="_blank"><b>Documentação: <i>Modules</i></b></a>

<br /><br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="30px"/> <a href="Mudar" target="_blank"><b>Código fonte da Classe AppModule</b></a>

<br /><br />

Agora, que temos uma primeira impressão dos blocos de construção mais importantes do aplicativo NestJS padrão, estamos prontos para iniciar o servidor e ver o que estamos obtendo como Resposta da nossa Requisição.

<h2>👣 Passo 05 - Executar o Projeto</h2>

1. De volta ao Terminal, acesse a pasta do projeto (hello-world) através do comando abaixo:

    ```bash
    cd hello-world
    ```

2. Verifique se você está dentro da pasta do projeto, como mostra a figura abaixo:

   <div align="center"><img src="https://i.imgur.com/Z05eS9Y.png" title="source: imgur.com" /></div>

3. Digite o comando ***npm run start:dev***, para compilar e executar o nosso projeto **hello-world**. 

   ```bash
   npm run start:dev
   ```

4. Neste momento o Nest em conjunto com o Node varre todo o seu projeto procurando por **TODAS** as Classes  e checará se o código está correto ou se falta algum pacote. Observe que o endpoint para o Método getHello() também foi mapeado, como indicado na imagem abaixo em amarelo:

<div align="center"><img src="https://i.imgur.com/opB6yfE.png" title="source: imgur.com" /></div>

<h2>👣 Passo 06 - Testar no Insomnia</h2>

Para testar a aplicação, utilizaremos o aplicativo **Insomnia**. 

<br />

<div align="left"><img src="https://i.imgur.com/g1HCNZy.png" title="source: imgur.com" width="30px" /><a href="https://insomnia.rest/" target="_blank"><b>Site Oficial do Insomnia</b></a></div>

<br />

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left"> **DICA:** *Caso você tenha alguma dúvida quanto a instalação do Insomnia, consulte o <a href="../00_ambiente/05_install_Insomnia.md" >Guia de Instalação do Insomnia.</a>* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

O Insomnia é um API Client que simplifica o processo de desenvolvimento do Backend de uma aplicação WEB. O Insomnia permite criar, compartilhar e testar aplicações WEB de forma simples e prática. O Insomnia permite aos  usuários criar e salvar requisições **HTTP e HTTPS** (Request) desde as mais simples até as mais complexas, bem como ler as suas respostas HTTP (Response).

Para testar a nossa API, vamos criar uma requisição do tipo **GET**, onde iremos indicar o servidor (localhost), a porta padrão do Spring (8080) e o endereço do recurso (/).

1. Na janela principal do Insomnia, clique no botão **Create** e clique na opção **Request Collection**.

<div align="center"><img src="https://i.imgur.com/OzaorsG.png" title="source: imgur.com" /></div>

2. Na janela que será aberta, informe o nome da Collection (**Hello World**) e clique no botão **Create** para concluir. 

<div align="center"><img src="https://i.imgur.com/9ps4Giq.png" title="source: imgur.com" /></div>

3. Na **Collection Hello World**, clique no botão <img src="https://i.imgur.com/Igkx9ev.png" title="source: imgur.com" width="25px"/>. No menu que será aberto, clique na opção **New Request**.

<div align="center"><img src="https://i.imgur.com/ntAuPY0.png" title="source: imgur.com" /></div>

<br /><br />

4. Informe o nome da requisição e o Método HTTP que será utilizado (**GET**), indicado na imagem na cor azul. Clique no botão **Create** para concluir. 

<div align="center"><img src="https://i.imgur.com/zZ2uTqH.png" title="source: imgur.com" /></div>

5. Configure a requisição conforme a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/BshaIVE.png" title="source: imgur.com" /></div>

6. No item marcado em amarelo na imagem acima, informe o endereço da Requisição. A requisição **Hello World** foi configurada da seguinte maneira:

- A primeira parte (http://localhost:3000/) é o endereço do servidor local e a requisição será enviada para o endereço raiz da aplicação.. 

7. Para testar a requisição, com a aplicação rodando, clique no botão <img src="https://i.imgur.com/sy0V8Nx.png" title="source: imgur.com" width="50px"/>.

8. O resultado da requisição você confere na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/NhDqxZl.png" title="source: imgur.com" /></div>

Se a mensagem de boas vindas: **Hello World !!!** for exibida, a aplicação está funcionando corretamente.

<br /><br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="30px"/> <a href="Mudar" target="_blank"><b>Código fonte do projeto</b></a>	

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
